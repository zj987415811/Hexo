---
title: 消息队列之RocketMQ
date: 2018-08-09 15:55:19
tags: RocketMQ
---
## RocketMQ 介绍##
- 概述
	- 推模式
	- 拉模式-长连接，低延迟
- 组成
	- NameServer:轻量级方式提供服务发现和路由功能，每个NameServer存有全量的路由信息，提供对等的读写服务，支持快速扩容。负责对数据源的管理，包括Topic和路由信息的管理，Broker启动的时候会去nameServer注册并定时发送心跳，Producer启动的时候会到NameServer上拉取Topic所属的broker具体地址，然后向具体的broker发送消息。
	- Producer:由用户进行分布式部署，消息由producer通过多种负载均衡策略发送到Broker集群，发送低延时，支持快速失败。
	- Consumer:由用户部署，支持push和pull两种消费模式，支持集群消费和广播消费，通过实时的消息订阅。
- 消息模型
	- Message
	- Topic
	- Queue
	- Group
- 服务端整体架构设计
	- 最上层授权和认证部分，TCP基于自行研发的线路层协议，需要编解码以及序列化。
	- 健康检查
	- 流控和熔断措施，对系统进行流量保护，针对不同维度的流量控制
	- 存储
- SDK架构图
	- 首先发现服务，需要找到发送消息或者接收消息具体的broker,以及broker上topic；
	- 然后SDK还需要保持长连接活；
	- 其次流量控制熔断机制
	- 保证实现高科而用，需要提供补偿机制，重投和重复。
	- 元信息通知更新消息。
- 技术点
	- 消息的顺序
		- RocketMQ全局保序，保证对通道的单一实例操作，单进程，单线程，线程读；
		- 牺牲吞吐量
	
	- 消息去重：失败重传
	- 分布式挑战：RocketMQ追求AP,通常情况下，通过降级，限流，熔断机制来保证洪峰下的可用性。金融级高频交易典型场景：CP机制，牺牲可用性来保证数据一致性。基于ZAB协议，利用分布式锁和通知机制来保证多副本数据的一致性。
- 优化
	- JVM停顿 GC 线程池 CPU 内存 网卡
- 对比
	- Kafak和RocketMQ都是磁盘消费队列模式，对于同一个消费组，一个分区只支持一个线程新消费消息，过少的分区会导致消费速度大大落后于消息生成速度。在实际的生产环境中，一个topic会设置成多个分区的模式来支持多个消费者。
	- 分区增大性能下降的原因:Kafka的每个topic，每个分区都会对应一个物理文件，当topic增加时，消息分散的落盘策略会导致磁盘I/O竞争激烈。而RocketMQ所有的消息都保持在同一个物理物件中，topic和分区数对rocketMQ也支持逻辑上的划分，不会增大太多影响。
	- 容量保证的策略：降级，限流，熔断
		- 降级：暂停边缘服务，保证核心服务的资源。
		- 在有限资源情况下，所提供的单位时间服务能力是有限的，如果超过了承受能力，可能会带来整个服务的停顿。应用的Crash，进而风险传递给服务调用方造成整个系统的服务能力丧失，进而引发雪崩。
		- 典型的限流算法:漏桶算法和令牌算法
			- 漏桶算法 一个桶以恒定的速率滴出，上方滴入速率超过滴出速率，就会导致水桶溢出过载。
			- 令牌桶算法 令牌以恒定速率放入桶，桶内令牌数有上限，每个请求会获取一个令牌，如果没有令牌了，则这个请求时过载的。
			- 信号量
	
		- 熔断：在分布式系统中，如果调用的远程服务或者资源由于某种原因无法使用时，没有过载保护就会导致请求资源阻塞在服务器上等待从而消耗掉系统或服务器资源。
	
			