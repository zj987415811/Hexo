---
title: 计算机网络总结复习
date: 2018-08-20 16:09:39
tags: 计算机网络
---
## 计算机网络复习 ##
1.域名访问流程
	1.ip地址查找
		1.浏览器查找缓存，是否有ip地址，无则继续
		2.操作系统操作缓存，无则继续
		3.路由器查找缓存，无则继续
		4.本地服务器查找缓存，无则继续
		5.根->顶级->权威
		6.告知其ip地址
	2.主机获取ip地址端口建立tcp连接，3次握手
	3.浏览器发送请求报文
	4.服务器接收报文，并向客户机发出确认请求；
	5.客户机收到后，发送确认已接收，完成tcp建立
	6.浏览器发出http协议的get请求等；
	7.服务器响应，并指定文件发送给浏览器；
	8.浏览器显示所有页面
2.版本2
	1.浏览器输入URL
	2.浏览器查看缓存，如果请求资源新鲜，则显示（建立连接？）
	3.浏览器缓存
		1.如果未还缓存，发起新请求
		2.浏览器查看缓存，如果新鲜，返回给客户端
		3.浏览器解析URL获取协议，主机，端口号，path
		4.组装HTTP请求报文
		5.浏览器获取主机ip地址，过程如下：
			1.浏览器缓存
			2.操作系统缓存
			3.hosts文件缓存
			4.路由器缓存
			5.isp DNS缓存
			6.DNS递归查询
		6.打开socket与ip地址，建立tcp连接
		7.TCP建立后发送http请求报文
		8.服务器接受请求并解析，将请求转发到服务器程序
		9.检查是否缓存信息，以及缓存信息是否新鲜
		10.将请求信息返回给浏览器
		11.四次挥手
		12.资源缓存
	版本3
	1.浏览器先尝试从hosts文件获取对应的ip地址。如果没有，则使用DNS协议来获取IP.
		1.浏览器查找缓存，是否有ip地址，无则继续
		2.操作系统操作缓存，无则继续
		3.路由器查找缓存，无则继续
		4.本地服务器查找缓存，无则继续
		5.根->顶级->权威
		6.告知其ip地址
	2.使用TCP协议，建立tcp连接。
		前提：需要用到ip协议 ARP协议
		1.发送syn x
		2.服务器发送syn ack x+1 y
		3.客户端发送syn ack y+1
	3.使用Http协议请求网页内容
	版本4
	1.总论：
		i.域名解析成ip地址；
		ii.与目的主机进行tcp连接(三次握手);
		iii.发送与收取数据(浏览器与目的主机开始http访问过程);
		iv.与目的主机断开tcp连接;
	2.域名解析成ip地址
		i.浏览器向本机DNS模块发出DNS请求，DNS模块生成相关的DNS报文;
		ii.DNS模块将生成的DNS报文传递给传输层的UDP协议单元;
		iii.UDP协议单元将该书封装成UDP数据报，传递给网络层的IP协议单元;
		iv.IP协议单元将该数据封装成IP数据包，其目的ip地址为DNS服务器的ip地址;封装好的ip数据包将传递给数据链路层的协议单元
		v.发送时在ARP缓存中查询相关数据，如果没有就发送ARP广播(包含带查询的IP地址，收到广播的主机检验主机的IP,符合条件的主机将含有自己MAC地址的ARP包发送给ARP广播的主机)请求，等待ARP回应;
		vi.得到ARP回应后，将IP地址与路由的下一跳MAC地址对应信息写入ARP缓存表;写入缓存后，以路由下一跳的地址填充目的的MAC地址，以数据帧形式转发;转发可能进行多次;
		vii.DNS请求到达DNS服务器的数据链路层协议单元;DNS服务器的数据链路层协议单元解析数据帧，将内部的ip数据包传递给网络层IP协议单元；DNS服务器的IP协议单元解析IP数据包，将内部的UDP数据报传递给传输层UDP协议单元;DNS服务器的UDP协议单元解析收到的UDP数据报，将内部的DNS报文传递给DNS服务单元;
		viii.DNS服务单元将域名解析成对应IP地址，产生DNS响应报文;DNS回应报文->UDP-IP-MAC->我的主机;本地主机收到数据帧，将数据帧->IP->UDP->浏览器;将域名解析结果以域名和IP地址对用形式写入DNS缓存表；
	3.与目的主机进行tcp连接
		1.SYN seq = x;
		2.SYN ACK Ack=x+1;seq = y;
		3.ACK Ack = y+1;
	4.发送与收取数据(浏览器与目的主机开始HTTP访问过程)
		1.浏览器向域名发出GET方法报文;--->HTTP请求
		2.报文通过TCP->IP(DNS)->MAC(ARP)->网关->目的主机；
		3.目的主机收到数据帧，通过IP->TCP->HTTP，HTTP协议单元会回应HTTP协议格式封装好的HTML形式数据；--->HTTP响应：从请求信息中获取客户机想要访问的主机名，从请求信息中获客户机想要访问的web应用。从请求信息中获取客户机要访问的web资源。（即各种文件，图片，视频，文本等）读取响应的主机下web应用，web资源，用读取的web资源数据，创建一个HTTP响应。
		4.该HTML通过TCP->IP->MAC->网关->我的主机
		5.我的主机收到数据帧，通过IP->TCP->HTTP->浏览器，浏览器以网页形式显示HTML内容。
	5.与目的主机断开TCP连接(四次挥手)
		1.浏览器向目的主机发出TCP连接结束的请求报文，此时进入FIN WAIT状态；该报文FIN标志位设为1，表示结束请求；TCP结束请求报文通过IP(DNS)->MAC(ARP)->网关->目的主机;目的主机收到数据帧，通过IP->TCP,TCP协议单元回应结束应答报文；
		2.目的主机收到数据帧，通过IP->TCP,TCP协议单元回应结束应答报文；
		3.当前收到回应，因为目的主机还有数据要传，不急于断开连接；
		4.该报文中ACK标志设为1，表示收到结束请求；
		5.目的数据发送完所有数据后，向客户端发出TCP连接结束请求报文；该报文把FIN标志位设为1，表示结束请求；TCP结束请求报文通过IP->MAC->网关->我的主机；
		6.客户端收到数据帧，通过IP->TCP，TCP协议单元回应结束应答报文，此时进入TimeWait状态；
		7.该报文中FIN均设为1，表示结束应答；
		8.目的主机关闭连接；Time Wait等待结束后。
		
		
3.TCP/UDP区别
	1.TCP 面向连接可靠运输协议 UDP面向非连接不可靠
	2.TCP报文段首部20字节，UDP报文段8字节
	3.TCP有拥塞控制和流量控制，而UDP没有
	4.TCP连接过程有3次握手，4次挥手，时延较大，UDP时延较小
	5.TCP是一对一连接 UDP可以一对一一对多
4.GET/POST的区别
	1.get请求会被缓存，保留在浏览器历史记录中，可作为收藏书签，不应再处理敏感数据时使用，有请求长度限制；
	2.post请求不会被缓存，不会保留书签和浏览器历史记录；
	3.对长度没要求；
5.DNS使用的协议
	1.既使用TCP也使用UDP,UDP报文长度最大512字节，当DNS查询超过512字节时，协议的TC标志出现删除标志，这时候使用TCP发送。
	2.区域传送时使用TCP:
		1.辅域名服务器会定时向主域名服务器进行查询以便了解数据是否有变动。如有变动，执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP；
		2.TCP是一种可靠连接，保证了数据的准确性。
	3.域名解析使用UDP	
6.幂等
7.Cookie和Session区别
	1.Cookie是一种能够让网站服务器把少量数据存储在客户端硬盘或内存，或是从客户端的硬盘读取数据的一种技术。当你浏览某网站时，由web服务器置于硬盘上的一个非常小的文本文件，他可以记录你的用户ID,密码，浏览过的网页，停留信息；
	2.Session:当用户请求来自应用程序的web页时，如果该用户还没有会话，则web服务器自动创建一个Session对象。当会话过期或者被抛弃后，服务器终止该会话。
	3.Session采用在服务器端保持状态的方案，cookie是在客户端保持状态的方案。由于服务器端保持状态的方案在客户端需要保持一个表示，所以session机制需要借助cookie机制来达到保存标识的目的。
	4.Session是服务器用来跟踪用户的一种手段，每个session都有一个唯一标识：SessionID;当服务器创建了Session时，给客户端发送的响应报文包含了SetCookie字段，其中有一个名为sid的键值对，这个键值SessionID,客户端收到后就把cookie保存到浏览器，并发之后发送的请求报表都包含SessionID。Http就通过Session和Cookie这两个发送一起合作来实现用户状态跟踪，Session用于服务端，Cookie用于客户端。
8.TCP粘包和拆包产生的原因
	1.应用程序写入数据的字节大小大于套接字发送缓冲区大小;
	2.进行MSS大小的TCP分段。MSS是最大报文段缩写。
	3.payLoad大于MTU进行ip分片。MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。如果IP层有一个数据包要传，而且数据的长度比链路层的MTU大，那么IP层就回进行分片，把数据报分成若干片，让每一个片都不超过MTU。IP分片可以发生在原始发送端主机上，也可以发生在中间路由器上。
9.TCP粘包拆包的解决策略
	1.消息定长
	2.在包尾部增加回车空格等特殊字符进行分割，如FTP；
	3.将消息分为消息头和消息尾；
	4.其他复杂的协议；
10.三次握手
	1.建立连接时，客户端发送syn包到服务器，并进入syn_Send状态，等待服务器确认；
	2.服务器收到Syn包，必须确认客户的syn，同时也发送自己的syn包，此时服务器进入syn_recv状态；
	3.客户端端收到SYN+ACK包，向服务器发送确认包ACK,客户端和服务器进入ESTABLISHED状态，完成3次握手。
	4.QA:
		i.为了保证服务端能够收到客户端信息并且能够做出正确的应答而进行前两次握手，为了保证客户端能够接收到服务端的信息并能够做出正确的应答而进行后二次握手；
		ii.三次握手的本质是信道不可靠，但是通信双方需要就某个问题达成一致，而要解决这个问题，无论你在消息中包含了什么信息，三次通信是理论上的最小值，所以三次握手不是tcp本身的要求，而是为了满足:在不可靠信道上可靠地传输信息，本质需求是，信道不可靠，数据传输要可靠，三次是最小带价值；
		iii.为什么进行三次握手：为了防止已失效的链接请求报文又突然传送到服务端，因而产生错误。为了解决网络中存在延迟的重复分组问题。
		iv.例：client发出的第一个链接请求报文段并没有丢失，而是在某个网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达Server。本来这是一个早已失效的报文段，但Server收到此失效的连接请求报文后，就误以为是client再次发出一个新的连接请求。于是就向client发出确认报文段，同一建立连接。假设不采用三次握手，那么server确认就建立连接了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发出数据，但server却认为新的运输连接已经建立，并一直等待Client发来数据。这样就浪费了server的资源。防止造成服务端资源浪费。
11.Socket
	1.网络通信必须的五种信息:连接使用的协议，本地主机的ip地址，本地进程的协议端口，远地主机的IP地址+端口;
	2.建立socket:一对套接字，一个运行于客户端，一个运行于服务端。连接分为3个过程：服务器监听，客户端请求，连接确认。
12.四次挥手
	1.客户端线发送FIN,进入FIN_WAIT状态
	2.服务端收到FIN,发送ACK,进入CLOSE_WAIT状态，客户端收到这个ACK,进入FIN_WAIT状态
	3.服务端发送FIN，进入LAST_ACK状态
	4.客户端收到FIN,发送ACK，进入TIME_WAIT状态，服务端收到ACK,进入CLOSE状态
	5.QA:
		i.TCP协议是一种面向连接可靠的基于字节流的运输层通信协议。TCP是双全工模式，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了。主机1告诉主机2，它的数据已经全部发送完毕了；但是这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2可以发送数据到主机1；当主机2发送FIN报文段时候，这个时候表示主机2也没有数据要发送了，就会告诉主机1，之后就断开。
		ii.服务端在Listen状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里面发送给客户端。而关闭连接时，当收到对方的FIN。
13.TCP如何保证可靠传输
	1.三次握手
	2.将数据截断为合理的长度。应用数据被分割成TCP认为最适合发送的数据块；按字节编号，合理分片；
	3.超时重发。当TCP发出一个段后，它启动一个定时器，如果不能及时收到一个确认就重发；
	4.对于收到的请求给出确认响应；
	5.校验出包有错，丢弃报文段，不给出响应；
	6.对于失序数据进行重新排序，然后才交给应用层；
	7.对于重复数据，能够丢弃重复数据；
	8.流量控制，TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。
	9.拥塞控制，当网络拥塞时，减少数据的发送。
14.详细介绍HTTP
	1.1.0和2.0的区别
		1.多路复用，允许单一的http/2连接同时发起多重请求-响应消息。
		2.二进制分帧，位于应用层和传输层之间。
		3.首部压缩
		4.HTTP2.0支持服务器推送
15.HTTPS和HTTP
	1.https协议需要到CA申请证书；
	2.http时超文本传输协议，信息是铭文传输;https是具有安全性的ssl加密传输协议；
	3.http和https使用的是完全不同的连接方式，用的端口不一样，前者是80，后者是443;
	4.http的连接很简单，是无状态的；https协议由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议；
	
	
		

