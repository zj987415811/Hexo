---
title: 微服务系列之源初
date: 2018-08-28 11:10:23
tags: 微服务设计读书笔记
---


## 写在前面 ##
>近期安排主要路线：
>
>- 微服务->service mesh->dubbo相关源码<br>
>- 设计模式->主流框架设计模式总结
>- 微服务系列主要以微服务设计+深入理解SpringCloud与微服务构建这两本书的读书笔记为主。
<!-- more -->
# 微服务设计读书笔记 #
## 0. 前言 ##
	微服务是一种分布式解决方案，推动细粒度服务的使用，这些服务协同工作，并且每个服务都有自己的生命周期。微服务主要围绕业务领域建模，所以避免了传统的分层架构引发的问题。避免了面向服务的架构中的陷阱。

## 1.微服务 ##
	i.领域驱动设计---用代码呈现真实世界的重要性。
	ii.六边形架构理论--->替代分层架构--->更好的体现业务逻辑。借助虚拟化平台可以按需创建机器并且调整大小，借助基础设施自动化，可以从一台机器扩展到多台。
	iii.领域驱动设计，持续交付，按需虚拟化，基础设施自动化，小型自治团队，大型集群系统--->微服务诞生。
### 1.1 什么是微服务 ###
>微服务就是一些协同工作的小而自治的服务。
#### 1.1.1 很小专注于做好一件事 ####
1. 在一个单块系统内，通常会创建一些抽象层或者模块来保证代码的内聚性；内聚性是指将相关代码放一起，在考虑使用微服务的时候，**内聚性很重要**；
2. 单一职责原则：把因相同原因而变化的东西聚合在一起，而把因不同原因而变化的东西分离开来。
3. 微服务的理念应用在独立的服务上。根据业务的边界来确定服务的边界，从而确定某个功能代码应该放在那里。
4. 小->服务管理难度增加

#### 1.1.2 自治性 ####
1. 一个微服务就是一个独立的实体，可以独立部署在PAAS上，作为操作系统独立进程存在。避免将多个服务部署在同一台机器上。通过隔离也会带来一定量的代价，但是能够简化分布式系统的构建。
2. 服务之间均通过网络进行通信，加强了服务之间的隔离性，避免紧耦合。
3. 服务可以彼此间独立进行修改，某一个服务的部署不应该引起服务消费方的变动。对于一个服务来说，需要考虑什么应该暴露，什么应该隐藏。如果暴露过多会造成消费方与服务的内部实现产生耦合，使得服务和消费方之间产生额外的协调工作，从而降低服务的自治性。
4. 服务会暴露出API,然后服务之间通过这些API进行通信。API的实现技术应该避免与消费放耦合，这就意味着应该选择与具体技术不相关的API实现方法，以保证技术的选择不被限制。
5. 如果系统没有很好地解耦，那么一旦出现问题，所有功能都将不可用

### 1.2 主要好处 ###
#### 1.2.1 技术异构性 ####
1. 一个由多个服务相互协作的系统中，可以在不同的服务中使用最合适改服务的技术。通用的技术不会得到很好的性能。
2. 如果系统中一部分需要做性能提升，可以使用性能更好的技术栈重新构建该部分。**系统中不同部分可以使用不同的数据存储技术，比如社交网络来说，图数据库能够更好地处理用户之间的交互操作，对于用户发布的帖子，使用文档数据库可能更好的选择。异构架构。**
3. 微服务可以帮助我们更快地采用新技术，并且理解这些新技术的好处。--->单块降低风险。
#### 1.2.2 弹性 ####
1. 如果系统中的一个组件不可用了，但并没有导致级联故障，那么系统的其他部分还可以正常运行。服务边界就是一个很显然的舱壁。
2. 在单块系统中，如果服务不可用，那么所有的功能都会不可用，那么对于单块服务的系统而言，可以通过将同样的实例运行在不同的机器上来降低功能完全不可用的概率，微服务本身能够很好地处理服务不可用和功能降级的问题。
#### 1.2.3 扩展 ####
#### 1.2.4 简化部署 ####
 几百万行的单块应用程序中，即使只修改一行代码也需要重新部署整个应用程序才能发布改变更。
#### 1.2.5 与组织结构相匹配 #### 
#### 1.2.6 可组合性 ####
1. 单纯考虑桌面网站或者移动应用程序时代过去，现在需要考虑的应用程序包括web，原生应用，移动端web,平板应用以及可穿戴设备等。
2. 在微服务架构中，系统会开放很多接缝供外部使用。当情况发生改变的时候，可以使用不同的方式构建应用，而整体化应用程序只能提供一个非常粗粒度的接缝供外部使用。

### 1.3 面向服务架构 ###
	1.SOA是一种设计方法，其中包含多个服务，服务之间通过配合最终提供一系列功能。服务之间通过网络调用，而非采用进程内调用的方式进行通信。
	2.SOA遇到的问题：通信协议的选择，第三方中间件的选择，服务粒度如何确定，如何划分系统。

## 2.演化式架构师 ##
### 2.1 不确定的比较 ###
	1. 架构师的职责:确保团队由共同的技术愿景，以帮助我们向客户交付他们想要的系统。
	2. 架构师的影响:所构建系统的质量，同事的工作条件，组织应对变化的能力等。
### 2.2 架构师的演化视角 ###
	1. 软件中会面临大量需求变更，使用的工具和技术也具有多样性。必须改掉从一开始就要设计出完美产品的想法，相反应该设计出一个合理的框架，在这个框架下可以慢慢演化出正确的系统。
	2. 架构师应该像城市规划师那样专注在大方向上，只有很有限的情况下参与到非常具体的细节实现中来。他们需要保证系统不但能够满足当前需求，还能够应对将来的变化。
### 2.3 分区 ###
	1. 代码架构师--->团队
### 2.4 一个原则性的方法 ###
	做系统设计方面决定通常在于舍取，微服务中需要舍取更多。如数据存储技术，如何带来过呢更好的可伸缩性技术。系统种是否可接受两种技术栈，做某些决策所需要的信息获取。
#### 2.4.1 战略目标 ####
	公司的走向 客户的满意程度
#### 2.4.2 原则 ####
	目标->规则。组织上线周期，交付团队应该对整个软件生命周期有完全的控制权。
	Heroku的12Factors原则
#### 2.4.3 实践 ####
	1. 通过相应的实践来保证与那则能够得到实施，这些实践知道我们如何完成任务。这些实践通常与技术相关，并且较为底层。任何开发人员都能够理解。这些实践包括代码规范，日志数据集中捕获，或者http/rest作为标准集成风格等。
	2. 由于偏技术层面，其改变频率会高于原则。
	3. 实践有时候会反映出组织内的一些限制。
	4. 实践应该巩固原则
#### 2.4.4 将原则和实践相结合 ####
	1.Http/Rest作为原则，而不是实践，
#### 2.4.5 真实世界的例子 ####
### 2.5 要求的标准 ###
	1.系统允许多少可变性
	2.我们需要识别出各个服务需要遵守的通用规则
	3.给出一个好服务的例子来阐释好服务的特点
#### 2.5.1 监控 ####
	1. 能够清晰的描绘服务系统的健康状态非常关键。这是系统级别的而不是单个服务级别进行考虑的。
	2. 在需要诊断一个跨服务问题或者想要了解更大趋势时，需要知道每个服务的健康状态。
	3. 所有的服务使用相同的方式报告健康状态以及监控相关的数据。
	4. 推送机制:每个服务主动把数据推送到某个集中的为止。使用Graphite来收集数据，使用Nagios来检测健康状态。总之尽量标准化。
	5. 每个服务内的技术应该对外不透明，并且不要为了服务的具体实现而改变监控系统，日志功能和监控情况类似，需要集中式管理。
#### 2.5.2 接口 ####
#### 2.5.3 架构安全性 ####
	1. 必须保证每个服务都可以应对下游服务的错误请求。
	2. 如果下游错误请求的服务堆积，就会使系统脆弱。每个下游服务使用他们自己的连接池，进一步让每个服务使用一个断路器。
	3. 返回码应该遵守一定的规则。
### 2.6 代码治理 ###
	提供范例和服务代码模板
#### 2.6.1 范例 ####
	1. 编写文档 
	2. 代码
#### 2.6.2 裁剪服务代码模板 ####
### 2.7 技术债务 ###
	1. 为了发布一些紧急的特性，会忽略一些约束。这是另一个需要做的取舍。技术愿景有其本身的道理。
	2. 偏离了这个愿景短期内会带来利益，但是长期看来需要付出代价。可以使用技术债务来理解这个取舍。
	2. 架构师的职责就是从更高层次触发，理解如何做权衡。理解债务的层次及其对系统的影响非常重要。
	3. 架构师应该能够提供一些温和的指导，然后让团队自行决定如何偿还这些技术债务。结构化，维护一个债务列表，定期回顾。
### 2.8 例外管理 ###
	1. 如果系统偏离了原则和实践，就可以针对某个规则破例，然后记录，如果出现多次可以通过修改原则和实践的方式把我们的理解固化下来。
	2. 如，在一般情况使用MySQL，在海量存储的场景应该使用**Cassandra**；
	3. 于是就可以修改原则，在大多数场景使用MySQL做存储，在数据快速增长的场景，使用Cassandra。
### 2.9 集中治理和领导 ###
	1. 架构师的部分职责是治理，COBIT给出的定义:治理通过评估干系人的需求，当前情况下以及下一步的可能性来确保企业目标的达成，通过排优先级和做决策来设定方向。对于已经达成一致的方向和目标进行监督。
	2. 架构师的职责是确保有一个技术愿景，治理就是要确保我们构建的系统符合这个愿景，而且在需要的时候还应对愿景进行演化。 

## 3.如何建模服务 ##

### 3.1 MusicCorp简介 ###
### 3.2 什么样的服务是好服务 ###
### 3.2.1 松耦合 ###
	1. 修改一个服务不需要修改另一个服务。
 	2. 使用微服务，能够独立修改及部署单个服务而不需要修改修通的其他部分。
 	3. 一个松耦合的服务应该尽可能少的直到与之协作的那些服务的信息。应该限制两个服务之间不同调用形式的数量。不仅是性能还有，过度通信导致的紧耦合。
### 3.2.2 高内聚 ###
	1. 把相关的行为聚集在一起，把不相关的行为放在别处。
	2. 如果想改变某个行为，最好能够只在一个地方修改，然后就可以尽快地发布。
	3. 如果需要在很多不同的地方修改就需要同时发布多个微服务才能够交付这个功能。
	4. 在很多个地方进行修改会很慢，同时部署多个服务风险也高。
	5. 找到问题的边界就可以确保相关的行为可以放在同一个地方，并且他们会与其他边界以尽量松耦合的形式进行通信。

### 3.3 限界上下文 ###
	1. 领域驱动设计主要专注如何实现世界的领域进行建模。如通用语言，仓储，抽象等。其中引入了限界上下文文。
	2. 任何一个给定的**领域都包含多个限界上下文**，这个上下文中的东西分成2部分，**一部份不需要与外部通信，另一部分则需要。**每个上下文都有明确的接口，该接口决定了它会暴露哪些模型给其他上下文。
	3. 另一个限界上下文定义：**一个由显式边界限定的特定职责**，如果想从一个限界上下文中获取信息，或者向其发起请求，需要使用模型和它的显式边界进行通信。、
#### 3.3.1 共享的隐藏模型 ####
#### 3.3.2 模块和服务 ####
	1. 同一个进程内使用模块来减少彼此之间的耦合也是一种选择。
	2. 微服务应该清晰地和限界上下文呢保持一致。
#### 3.3.3 过早划分 ####
### 3.4 业务功能 ###
### 3.5 逐步划分上下文 ###
	1. 一开始接触一些粗粒度的限界上下文，这里面可能会包含一些嵌套限界上下文。
	2. 当考虑微服务边界时，首先考虑比较大，粗粒度的那些上下文，当发现合适的缝隙后，再进一步划分出且套上下文。

## 4.集成 ##
### 4.1 集成技术 ###
	1. SOAP XML-RPC REST Protocol Buffers 
	2. 易于使用，隐藏内部实现细节
### 4.2 为用户创建接口 ###
### 4.3 共享数据库 ###
### 4.4 同步和异步 ###
	1. 请求/响应：客户端发起一个请求，然后等待响应。
	2. 异步通信:发起一个请求，然后注册一个回调，当服务端操作结束后，会调用该回调。
	3. 基于事件的协作方式，客户端不是发起请求，而是发布一个事件，然后期待其他的协作者接收该消息，并且知道怎么做。
	4. 基于事件的系统天生是异步，并且业务逻辑不是集中式的而是平均分布在不同的协作者中。
	5. 基于事件的协作方式耦合性很低。客户端发布一个事件，但不需要知道谁或者什么会对此做出响应，也就是说不影响客户端的情况下，对该事件添加新的订阅。
### 4.5 编排与协同  ###
	1. 编排：依赖于某个中心大佬指导并驱动整个流程。
		1.让客户服务作为中心大脑
		2.过于依赖中心大脑
	2. 协同：仅仅告知系统中各个部分各自的职责，而具体怎么做的细节留给他们自己，同时也会响应周围其他人。
		1. 协同可以降低系统的耦合度，并且可以更加灵活地对现有系统进行修改。但是需要额外的工作来对业务流程做跨服务的监控。
		2. 同步调用简单，如果想要请求/响应风格的语义，又想避免其在耗时业务上的困境，可以采用异步请求加回调的方式。
		3. 使用异步方式有利于协同方案的实施，从而大大减少服务间的耦合，这是能独立发布服务而追求的特性。
	3. 针对请求/响应方式，可以考虑2中技术:RPC和REST

### 4.6 远程过程调用 ###
	1. 允许你进行一个本地调用，但是实际结果由某个远程服务器产生。PRC种类繁多，其中一些依赖于接口定义（SOAP,Thrift,Protocol buffers等）。不同的技术栈可以通过接口定义轻松生成客户端和服务端的桩代码。
	2. 用JAVA服务暴露一个SOAP接口，然后使用WSDL定义接口生成.net客户端的代码。
	3. 很多技术本质上是二进制的，比如JAVA RMI,Thrift,protocol buffers等，SOAP使用XML作为消息格式。有些RPC实现与特定网络协议相绑定，同时也有不同的协议实现。
	4. Tcp能够保证送达，UDP虽然不能保证送达，但是协议开销较小。
### 4.7 REST ###
	1. Rest是RPC的一种替代方案；
	2. 资源，处于服务之内。服务可以根据请求内容创建消费对象的不同表现形式，一个资源的对外显示方式和内部存储方式之间没有耦合。
	3. 例如，客户端可能会请求一个customer的json表示形式，而customer内部存储方式可以完全不同。客户端一旦得到该customer得表示，就可以发出请求对其进行修改，而服务器可以选择应答与否。
	4. **Richardson的成熟度模型**
	5. REST本身没有提及底层的协议，最常用的是http，或者usb，串口等等。
#### 4.7.1 Rest和Http ####
	http的方法get,post可以很好和资源一起使用。Rest架构风格声明了一组对所有资源的标准方法，HTTP恰好也定义了一组方法供使用。GET使用幂等的方式获取资源，Post创建一个新资源。
#### 4.7.2 超媒体作为程序状态引擎 ####
	1. 超媒体:有一块内容，该内容包含了指向其他内容的链接，而这些内容的格式可以不同，如文本，图像，声音等。你可以在任何一个网页上看到超媒体控制形式的链接，当你点击时可以看到相关的内容，
	2. **Rest实战**
### 4.8 试下基于事件的异步协作方式 ###
#### 4.8.1 技术选择 ####
	1. 微服务发布事件机制和消费者接收事件机制。尽量让中间件保持简单，把业务逻辑放在自己的服务中。 
	2. 使用HTTP来传播
#### 4.8.3 异步机构的复杂性 ####
	1. 复杂性：不仅仅是对于消息发布订阅操作，对于非常耗时的异步请求/响应，需要考虑返回时怎么处理。该响应是否回到发送请求那个节点？如果是，节点停止服务怎么办?如果不是，是否需要把信息事先存储到其他地方，以便于做相应处理？
	2. 如果API设计得当，短生命周期的异步操作很容易管理。但是需要思维的转换。
	3. 灾难性故障转移
### 4.9 服务即状态机 ###
### 4.10 响应式扩展 ###

## 5.分解单块系统 ##
### 5.1 关键是接缝 ###
1.高内聚，低耦合。
2.限界上下文:组织内高内聚和低耦合的边界。
### 5.2 分解项目 ###

1. 4个上下文
	- 产品目录：与正在销售商品相关的元数据
	- 财务:账户，支付，退款等项目的报告
	- 仓库:分发客户订单，处理退货，管理仓库等
	- 推荐：推荐算法
2. 创建包结构来表示上下文，用IDE重构功能来自动完成代码移动。
### 5.3 分解单块系统的原因 ###
1. 改变的速度
2. 团队结构
3. 安全
4. 技术
5. 依赖
6. 数据库
7. 找到问题的关键
### 5.4 事务边界 ###
1. 事务:要么全部做完，要么什么都不变。 
2. 重试
3. 快速失败
4. 分布式事务
	1. 事务管理器
	2. 事务运行在不同的进程种，通过网络进行通信
	3. 二阶段提交：投票阶段，很容易让所有参与者都等待中央协调进行的指令，从而容易导致系统中断。
### 5.5 通过服务调用来获取数据 ###
### 5.6 数据导出 ###
## 6.部署 ##
### 6.1 持续集成 ###
1. CI能够保证新提交的代码与已有代码进行集成，从而让所有人保持同步。CI服务器会检测到代码已提交并签出，然后花些时间来验证代码是否通过编译以及测试是否通过。
