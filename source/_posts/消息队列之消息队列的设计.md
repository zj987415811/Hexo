---
title: 消息队列之消息队列的设计
date: 2018-08-09 16:46:53
tags: 消息队列
---
## 消息队列的设计 ##
- 使用场景
	- 业务解耦 最终一致性 广播 削峰填谷 流量控制
	- 强一致性用RPC
- 如何设计一个消息队列
	- 配备Broker来堆积消息，消息的转存，最简单的消息队列可以做成一个消息转发器，把一次RPC看成2次RPC。
	- 首先Build一个整体数据流，P-B-C;
	- 利用RPC将数据流串起来，然后考虑RPC的高可用，尽量做到**无状态**；
	- 考虑如何承载消息堆积，并且在合适的时机投递消息，最加方式就是存储。存储的选型需要综合考虑性能和可靠性，开发维护成本等等。
	- 为了广播功能，我们需要维护消费关系，利用ZK或其他。
- 高级特性
	- RPC通信协议
		- 消息队列就是2次RPC加一个转存。加上消费端的确认所以大概是3次。从而牵涉到负载均衡，服务发现，通信协议，序列化等。
		- 利用现有的RPC框架。
	
	- 高可用
		- 所有的高可用都依赖于rpc和存储的高可用。
		- 幂等
	- 服务端承载消息堆积的能力
		- 错峰流控最终可达
		- 持久化非持久化
	- 消费关系解析
		- 点对点 
		- 广播
- 更高特性
	- 可靠投递（最终一致性）
		- 完全不丢消息--->消息重复--->每次要发生不可靠的事情之前，先将消息落地，然后发送。当失败或者不知道成功失败时，消息状态时待发送，定时任务不停的轮询所有待发送消息，最终一定可达。
		- 具体：
			- Producer往broker发送消息之前，先落地；请求到server后，server确保数据落地后再告诉客户端发送成功。
			- 支持广播的消息队列需要对每个待发送的endpoint，持久化一个发送状态，直到所有endpoint状态都Ok才可以删除消息。
			- 对于各种不确定(超时，宕机，消息没有送达，送达后没有落地，数据落地后没有回复)都属于消息没有送达。
			- 重推消息所面临的就是消息重复。重复和丢失就像两个噩梦。
	- 消费确认
		- 当Broker把消息投递给消费者后，消费者可以立即响应收到这个消息。但是这只是第一步，能否消费却不一定。或许是因为消费能力的问题，系统的符合已经不能处理这个消息；或者刚才状态机里面提到的消息不是想要的，主动要求重复。
		- 消息的送达和消息的处理分开，实现了消息队列的本质。
		- 对于reject和error，需要特别说明，滑动窗口/池
	- 重复消息和顺序消息
		- 顺序消息->发送方到服务方接收者都是单点单线程。
		- 没有绝对的顺序消息。
		- 在保证不丢消息的情况下，减少重复消息，不保证消息的投递顺序。
		- 消息重复：如何鉴别，并幂等处理，如何减少重复消息的投递。
		- 每个消息都有唯一身份。通过数据库/bloomfilter/分布式kv中的key都可以进行去重。
		- 通过版本号识别消息重复，状态机识别
- 消息队列的事务 --- RocketMQ
	- 2PC
		- prepare阶段---投票阶段，协调者向参与者确认是否可以共同提交。
		- commit阶段---得到全部参与者的所有回到后，协调者向所有的参与者发布共同提交或者共同回滚的指令。
		- 2pc的问题：超时状态，在发送完提交指令后，参与者没有收到提交或者回滚的指令时，此时不会是否资源。不足：同步阻塞 单点问题 数据不一致 保守
	- 3PC
		- 在commit之前增加了preCommit过程，使得在参与者收不到确认时，依然可以从容commit或者rollback,避免资源锁定太久而导致浪费。缺点：实现复杂 
	
	- TCC补偿性事务
		- 分为try confirm cancel
		- 事务管理器记录全局事务的推进状态，以及子事务的执行状态，负责推进各个子事务共同进行提交或者回滚。同时负责在子事务处理超时后不停重试，重试不成功后转手工处理，保证事务的最终一致性。
		- 优点：在尝试阶段仅仅时业务系统做验测，并保留业务资源，并没有真正提交。TCC仅需要释放保留资源，降低补偿成本。隔离性高
	- 事务消息
		- 事务消息的本质：消费加积分业务
- RocketMQ事务消息
	- 设计原则是为了解决Producer端的消息发送与本地事务执行的原子性问题。
	- RocketMQ的设计中broker与producer端的双向通信能力，使得broker天生可以作为一个事务协调者存在；
	- RocketMQ本身提供存储机制，为事务消息提供持久化能力；
	- RocketMQ的高可用机制以及可靠消息设计，为事务消息在系统发生异常时，依然能够保证事务达到最终一致性。
- RocketMQ事务消息设计
	- 事务消息作为一种异步确保型事务，将两个事务分支通过MQ进行异步解耦，RocketMQ事务消息的设计流程借鉴了两阶段提交理论。
	- 过程：
		- 事务发起方首先发送prepare消息到MQ;
		- 在发送prepare消息成功后执行本地事务;
		- 根据本地事务执行结果返回commit或者是rollback;
		- 如果消息是rollback，MQ将删除该prepare消息不进行下发，如果是commit消息，MQ将会把这个消息发送给consumer端。
		- 如果执行本地事务过程中，执行端挂掉，或者超时，MQ将会不停地询问其同组的其他producer来获取状态。
	- RocketMQ通过使用HalfTopic以及Operation Topic两个内部队列来存储事务消息推送状态。
		- Half Topic对应队列中存放prepare消息，Operation Topic对应的队列则存放了prepare message对应的commit/rollback消息，消息体中则是prepare message对应的offset，服务端通过对比两个队列的差值来找到尚未提交的超时事务进行回查。
	-  从用户侧来说，用户需要分别实现本地事务执行，以及本地事务回查方法，只需要关注本地事务的执行状态即可。
	-  在service层，对事物消息的两阶段提交进行了抽象，同时针对超时事务实现了回查逻辑，通过不断扫描当前事务推进状态，来不断反向请求Producer端获取超时事务的执行状态，在避免事务挂起的同时，也避免了Producer端的单点故障。
	-  在存储层，RocketMQ通过Bridge封装了与底层队列存储的相关操作，用以操作两个对应的内部队列，用户也可以通过其他存储介质来实现自己的service，RocketMQ会通过ServiceProvider加载进来。