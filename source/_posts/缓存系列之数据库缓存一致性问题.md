---
title: Redis系列之数据库缓存一致性问题
date: 2018-08-09 11:40:48
tags: Redis
---
##Redis缓存数据库一致性问题##
- 数据一致性处理
	- 当多个进程同时操作同一个数据，会产生资源争抢，数据一致性的问题。
	- 高并发情况下，涉及到写操作时，不能直接操作数据库，大量并发连接会导致mysql请求会阻塞，大量的insert update请求到，会导致无数的行锁和表锁，最后堆积很多，触发too many connections错误。
- 消息队列
	- 将票数资源存入redis中，将请求存入消息队列，list会阻塞，但是依次处理，导致等待时间较长。
- 加锁
	- 排他锁，乐观锁，悲观锁
	- 排他锁：进行写时，禁止一切读写；
	- 乐观锁：在写的时候，默认没有资源竞争，维护一个Version号，等处理后对照version号，一致则提交，否则回滚。
	- 悲观锁：在写的时候，别人也再写。采用数据库提供的锁机制：在写操作的时候(insert update)myisam采用表锁，innodb根据主键与否来决定是行锁还是表锁。读操作采用MVCC版本控制。
- 需求起因
	- 假设先写数据库，再淘汰缓存:第一步写数据库成功，第二步淘汰缓存失败，则BD中是新数据，Cache中是旧数据，数据不一致。
	- 假设先淘汰缓存，再写数据库：第一步淘汰缓存成功，第二步写数据库失败，则缓存中无数据，数据库中是旧数据。
	- 先淘汰缓存，再写数据库
- 数据不一致原因
	- 先操作缓存，再数据库成功之前，如果有读请求发生，可能导致旧数据入缓存，引发数据不一致。
	- 写流程：
		- 先淘汰缓存
		- 再写DB
	- 读流程
		- 先读cache,如果数据命中hit则返回；
		- 如果数据未命中miss则读DB;
		- 将DB中读取出来的数据入缓存。
- 问题解决思路---串行化
- Redis数据库与缓存一致性解决方案
	- 数据库与缓存读写模式策略---写完数据库后是否需要马上更新缓存还是直接删除缓存？
		- 如果写数据库的值与更新到缓存值是一样的，不需要经过任何计算可以马上更新缓存，但是对于写数据频繁而读数据少的场景并不合适这个解决方案。
		- 如果写数据库的值与更新缓存的值不一致，写入缓存中的数据需要经过几个表的关联计算后得到的结果插入缓存中，那么没必要立即更新缓存，删除缓存即可，等到查询的时候把计算结果插入到缓存中即可。
		- 一般的策略是当更新数据时，先删除缓存，再更新数据库。
	- 数据库与缓存双写情况下导致数据不一致问题
		- 场景1：当更新数据时，如更新某商品的库存，当前商品的库存为100，而现在为99，先更新数据库改成99，然后删除缓存，发现删除缓存失败，这时数据库存99，而缓存存100，导致缓存数据库不一致。
		- 解决方案：这种情况先删除缓存，再更新数据库。**如果缓存删除失败就不更新数据库**，如果说缓存删除成功，而数据库更新失败，那查询到的是数据库的旧数据，不会造成缓存数据库不一致的情况。
		- 场景2：在高并发情况下，如果当删除出完缓存的时候，这是去更新数据库，但是还没有更新完，这时另一个请求来查询，发现缓存没有，就去数据查。数据库中100，查到后加入缓存，插入完缓存后，原来那个数据库的线程把数据库更新为99，导致缓存数据库不一致。
		- 场景2解决：
			- 读请求时长阻塞
			- 请求并发量过高
			- 多服务实例部署的请求路由
			- 热点商品的路由问题，导致请求倾斜
